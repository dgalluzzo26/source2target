/**
 * API Service for Backend Communication
 * 
 * This module provides a type-safe, promise-based API client for communicating
 * with the FastAPI backend. All API calls go through a generic fetch wrapper
 * with standardized error handling.
 * 
 * Features:
 * - Type-safe request/response handling
 * - Automatic error catching and formatting
 * - Support for Databricks App deployment (relative URLs)
 * - Organized into logical API classes (Semantic, Mapping, AI)
 * 
 * @module services/api
 */

/**
 * Base URL for all API requests.
 * 
 * In Databricks App deployment, backend is on same domain (use relative URLs).
 * For local development, can be overridden via VITE_API_URL environment variable.
 */
const API_BASE_URL = import.meta.env.VITE_API_URL || ''

/**
 * Standard API response wrapper
 * 
 * @template T - Type of the data payload
 */
interface ApiResponse<T> {
  /** Successful response data */
  data?: T
  /** Error message if request failed */
  error?: string
}

/**
 * Health check response structure
 */
interface HealthResponse {
  /** Service health status */
  status: string
}

/**
 * Sample data item structure (for testing)
 */
interface DataItem {
  id: number
  name: string
  value: number
}

/**
 * Sample data response structure (for testing)
 */
interface DataResponse {
  data: DataItem[]
}

/**
 * Generic fetch wrapper with standardized error handling.
 * 
 * Wraps the native fetch API to provide:
 * - Automatic JSON content-type headers
 * - Consistent error handling
 * - Type-safe responses
 * 
 * @template T - Expected response data type
 * @param endpoint - API endpoint path (e.g., '/api/mapping/mapped-fields')
 * @param options - Optional fetch configuration (method, headers, body, etc.)
 * @returns Promise resolving to ApiResponse with data or error
 */
async function apiFetch<T>(endpoint: string, options?: RequestInit): Promise<ApiResponse<T>> {
  try {
    const response = await fetch(`${API_BASE_URL}${endpoint}`, {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...options?.headers,
      },
    })

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`)
    }

    const data = await response.json()
    return { data }
  } catch (error) {
    console.error('API Error:', error)
    return { error: error instanceof Error ? error.message : 'Unknown error occurred' }
  }
}

/**
 * Health Check
 */
export async function checkHealth(): Promise<ApiResponse<HealthResponse>> {
  return apiFetch<HealthResponse>('/api/health')
}

/**
 * Get Data
 */
export async function getData(): Promise<ApiResponse<DataResponse>> {
  return apiFetch<DataResponse>('/api/data')
}

/**
 * Example POST request
 */
export async function postData<T>(endpoint: string, data: unknown): Promise<ApiResponse<T>> {
  return apiFetch<T>(endpoint, {
    method: 'POST',
    body: JSON.stringify(data),
  })
}

// Placeholder exports for components that need them
export class SystemAPI {
  static async getStatus() {
    // Placeholder - not implemented yet
    return {}
  }

  static async getHealth() {
    // Placeholder - not implemented yet
    return {}
  }
}

export const handleApiError = (error: any) => {
  console.error('API Error:', error)
  return { error: 'An error occurred' }
}

// ============================================================================
// Semantic Table API
// ============================================================================

/**
 * Complete semantic table record (target field definition).
 * 
 * Represents a target database field that source fields can be mapped to.
 * Includes both logical names (for display) and physical names (for database operations).
 */
export interface SemanticRecord {
  /** Unique record identifier */
  id?: number
  /** Target table logical name (display) */
  tgt_table_name: string
  /** Target table physical name (database) */
  tgt_table_physical_name: string
  /** Target column logical name (display) */
  tgt_column_name: string
  /** Target column physical name (database) */
  tgt_column_physical_name: string
  /** Whether column is nullable ("YES" or "NO") */
  tgt_nullable: string
  /** Physical data type (e.g., "STRING", "INT", "DECIMAL") */
  tgt_physical_datatype: string
  /** Column description or comments */
  tgt_comments?: string
  /** Auto-generated semantic field text for vector search */
  semantic_field?: string
}

/**
 * Data for creating a new semantic table record.
 * 
 * Excludes id and semantic_field as they are auto-generated by the backend.
 */
export interface SemanticRecordCreate {
  /** Target table logical name */
  tgt_table_name: string
  /** Target table physical name */
  tgt_table_physical_name: string
  /** Target column logical name */
  tgt_column_name: string
  /** Target column physical name */
  tgt_column_physical_name: string
  /** Whether column is nullable ("YES" or "NO") */
  tgt_nullable: string
  /** Physical data type */
  tgt_physical_datatype: string
  /** Column description or comments */
  tgt_comments?: string
}

/**
 * Data for updating an existing semantic table record.
 * 
 * All fields are optional to support partial updates.
 * The semantic_field will be automatically regenerated by the backend.
 */
export interface SemanticRecordUpdate {
  tgt_table_name?: string
  tgt_table_physical_name?: string
  tgt_column_name?: string
  tgt_column_physical_name?: string
  tgt_nullable?: string
  tgt_physical_datatype?: string
  tgt_comments?: string
}

/**
 * API client for semantic table operations.
 * 
 * The semantic table contains all possible target fields that source fields
 * can be mapped to. This class provides CRUD operations for managing these
 * target field definitions.
 */
export class SemanticAPI {
  /**
   * Get all semantic table records.
   * 
   * Retrieves the complete list of target field definitions from the database.
   * Used in the Configuration page to display and manage available target fields.
   * 
   * @returns Promise with array of semantic records or error
   */
  static async getAllRecords(): Promise<ApiResponse<SemanticRecord[]>> {
    return apiFetch<SemanticRecord[]>('/api/semantic/records')
  }

  /**
   * Create a new semantic table record.
   * 
   * Adds a new target field definition to the semantic table. The backend will
   * auto-generate the record ID and semantic_field text.
   * 
   * @param record - New semantic record data (without ID)
   * @returns Promise with created record including auto-generated ID
   */
  static async createRecord(record: SemanticRecordCreate): Promise<ApiResponse<SemanticRecord>> {
    return apiFetch<SemanticRecord>('/api/semantic/records', {
      method: 'POST',
      body: JSON.stringify(record),
    })
  }

  /**
   * Update an existing semantic table record.
   * 
   * Partially updates a target field definition. Only provided fields will be
   * updated; others remain unchanged. The semantic_field will be regenerated.
   * 
   * @param recordId - ID of the record to update
   * @param record - Partial record data with fields to update
   * @returns Promise with updated record
   */
  static async updateRecord(recordId: number, record: SemanticRecordUpdate): Promise<ApiResponse<SemanticRecord>> {
    return apiFetch<SemanticRecord>(`/api/semantic/records/${recordId}`, {
      method: 'PUT',
      body: JSON.stringify(record),
    })
  }

  /**
   * Delete a semantic table record.
   * 
   * Removes a target field definition from the semantic table. This operation
   * is permanent and cannot be undone.
   * 
   * @param recordId - ID of the record to delete
   * @returns Promise with status message
   */
  static async deleteRecord(recordId: number): Promise<ApiResponse<{ status: string; message: string }>> {
    return apiFetch<{ status: string; message: string }>(`/api/semantic/records/${recordId}`, {
      method: 'DELETE',
    })
  }
}

// ============================================================================
// Mapping API
// ============================================================================

/**
 * A mapped source field with its target mapping.
 * 
 * Represents a source database field that has been successfully mapped to
 * a target field. Used in the "Mapped Fields" tab.
 */
export interface MappedField {
  /** Source table logical name */
  src_table_name: string
  /** Source column logical name */
  src_column_name: string
  /** Target column logical name (the mapping) */
  tgt_mapping?: string
  /** Target table logical name */
  tgt_table_name?: string
  /** Target column physical name */
  tgt_column_physical?: string
  /** Target table physical name */
  tgt_table_physical?: string
}

/**
 * An unmapped source field awaiting mapping.
 * 
 * Represents a source database field that has not yet been mapped to a target.
 * Contains metadata needed for AI suggestions and manual search.
 */
export interface UnmappedField {
  /** Source table logical name */
  src_table_name: string
  /** Source column logical name */
  src_column_name: string
  /** Source column physical name */
  src_column_physical_name: string
  /** Whether column is nullable ("YES" or "NO") */
  src_nullable: string
  /** Physical data type (e.g., "STRING", "INT") */
  src_physical_datatype: string
  /** Column description or comments */
  src_comments?: string
}

/**
 * API client for field mapping operations.
 * 
 * Handles all operations related to creating, viewing, and managing
 * source-to-target field mappings. This is the core functionality of
 * the application.
 */
export class MappingAPI {
  /**
   * Get all mapped fields for the current user.
   * 
   * Retrieves source fields that have been successfully mapped to target fields.
   * Results are filtered by the current user's email (from source_owners column).
   * Used in the "Mapped Fields" tab of the Mapping page.
   * 
   * @returns Promise with array of mapped fields or error
   */
  static async getMappedFields(): Promise<ApiResponse<MappedField[]>> {
    return apiFetch<MappedField[]>('/api/mapping/mapped-fields')
  }

  /**
   * Get all unmapped fields for the current user.
   * 
   * Retrieves source fields that have NOT been mapped yet (tgt_columns IS NULL).
   * Results are filtered by the current user's email.
   * Used in the "Unmapped Fields" tab of the Mapping page.
   * 
   * @returns Promise with array of unmapped fields or error
   */
  static async getUnmappedFields(): Promise<ApiResponse<UnmappedField[]>> {
    return apiFetch<UnmappedField[]>('/api/mapping/unmapped-fields')
  }

  /**
   * Download a CSV template with example source field structure.
   * 
   * Generates a CSV file with headers and one example row showing the required
   * format for bulk uploading source fields. Users can fill in additional rows
   * and upload the completed template.
   * 
   * @returns Promise with Blob containing CSV file
   * @throws Error if download fails
   */
  static async downloadTemplate(): Promise<Blob> {
    const response = await fetch(`${API_BASE_URL}/api/mapping/download-template`, {
      method: 'GET',
      credentials: 'include'
    })
    
    if (!response.ok) {
      throw new Error(`Failed to download template: ${response.statusText}`)
    }
    
    return await response.blob()
  }

  /**
   * Upload CSV template with source field mappings.
   * 
   * Processes a CSV file containing source field information. The backend will:
   * - Check each row for duplicates (same src_table_name + src_column_name)
   * - Insert new records with tgt_columns = NULL (unmapped)
   * - Skip duplicate records
   * 
   * The CSV should have columns: src_table_name, src_column_name,
   * src_column_physical_name, src_nullable, src_physical_datatype, src_comments.
   * 
   * @param file - CSV file to upload
   * @returns Promise with upload result including counts (successful, skipped, failed)
   */
  static async uploadTemplate(file: File): Promise<ApiResponse<any>> {
    const formData = new FormData()
    formData.append('file', file)
    
    const response = await fetch(`${API_BASE_URL}/api/mapping/upload-template`, {
      method: 'POST',
      credentials: 'include',
      body: formData
    })
    
    const data = await response.json()
    
    if (!response.ok) {
      return { data: null, error: data.detail || 'Upload failed' }
    }
    
    return { data, error: null }
  }

  /**
   * Remove mapping for a specific source field.
   * 
   * Sets tgt_columns to NULL for the specified field, effectively unmapping it.
   * The field will then appear in the "Unmapped Fields" tab.
   * 
   * @param srcTableName - Source table name
   * @param srcColumnName - Source column name
   * @returns Promise with success status or error
   */
  static async unmapField(srcTableName: string, srcColumnName: string): Promise<ApiResponse<any>> {
    return apiFetch<any>(
      `/api/mapping/unmap-field?src_table_name=${encodeURIComponent(srcTableName)}&src_column_name=${encodeURIComponent(srcColumnName)}`,
      { method: 'DELETE' }
    )
  }

  /**
   * Search the semantic table for manual mapping selection.
   * 
   * Performs a case-insensitive LIKE search across target table names,
   * column names, and comments. Returns up to 50 matching target fields
   * for the user to manually select from.
   * 
   * @param searchTerm - Text to search for in semantic table
   * @returns Promise with array of matching semantic records or error
   */
  static async searchSemanticTable(searchTerm: string): Promise<ApiResponse<any[]>> {
    return apiFetch<any[]>(
      `/api/mapping/search-semantic-table?search_term=${encodeURIComponent(searchTerm)}`
    )
  }

  /**
   * Save a manual mapping selected by the user.
   * 
   * Updates the mapping table by setting tgt_columns to the selected target
   * field information. This moves the source field from unmapped to mapped status.
   * 
   * @param srcTableName - Source table name
   * @param srcColumnName - Source column name
   * @param tgtTableName - Target table logical name
   * @param tgtColumnName - Target column logical name
   * @param tgtTablePhysical - Target table physical name
   * @param tgtColumnPhysical - Target column physical name
   * @returns Promise with success status or error
   */
  static async saveManualMapping(
    srcTableName: string,
    srcColumnName: string,
    tgtTableName: string,
    tgtColumnName: string,
    tgtTablePhysical: string,
    tgtColumnPhysical: string
  ): Promise<ApiResponse<any>> {
    return apiFetch<any>('/api/mapping/save-manual-mapping', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({
        src_table_name: srcTableName,
        src_column_name: srcColumnName,
        tgt_table_name: tgtTableName,
        tgt_column_name: tgtColumnName,
        tgt_table_physical: tgtTablePhysical,
        tgt_column_physical: tgtColumnPhysical
      })
    })
  }
}

// ============================================================================
// AI Mapping API
// ============================================================================

/**
 * AI-generated mapping suggestion with confidence score.
 * 
 * Represents an intelligent mapping recommendation generated by vector similarity
 * search (and optionally LLM reasoning). Suggestions are ranked by confidence.
 */
export interface AISuggestion {
  /** Suggestion rank (1 = best match) */
  rank: number
  /** Target table logical name */
  target_table: string
  /** Target column logical name */
  target_column: string
  /** Target table physical name */
  target_table_physical: string
  /** Target column physical name */
  target_column_physical: string
  /** Combined semantic field text */
  semantic_field: string
  /** Confidence score from vector search (0.0 to 1.0) */
  confidence_score: number
  /** Explanation/reasoning for the suggestion */
  reasoning: string
}

/**
 * API client for AI-powered mapping suggestions.
 * 
 * Uses Databricks Vector Search to find semantically similar target fields
 * based on source field metadata. Future enhancement will add LLM reasoning.
 */
export class AIMappingAPI {
  /**
   * Generate AI mapping suggestions for a source field.
   * 
   * Creates intelligent mapping recommendations by:
   * 1. Building a query string from source field metadata
   * 2. Performing vector similarity search against semantic table
   * 3. Ranking results by confidence score
   * 4. (TODO) Adding LLM-generated reasoning
   * 
   * @param srcTableName - Source table name
   * @param srcColumnName - Source column name
   * @param srcDatatype - Source data type (e.g., "STRING", "INT")
   * @param srcNullable - Whether source is nullable ("YES" or "NO")
   * @param srcComments - Source column description/comments
   * @param numVectorResults - Number of vector search results to retrieve (default: 25)
   * @param numAiResults - Number of top suggestions to return (default: 10)
   * @param userFeedback - Optional user feedback to refine suggestions (not yet implemented)
   * @returns Promise with array of ranked suggestions or error
   */
  static async generateSuggestions(
    srcTableName: string,
    srcColumnName: string,
    srcDatatype: string,
    srcNullable: string,
    srcComments: string,
    numVectorResults: number = 25,
    numAiResults: number = 10,
    userFeedback: string = ''
  ): Promise<ApiResponse<AISuggestion[]>> {
    return apiFetch<AISuggestion[]>('/api/ai-mapping/generate-suggestions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        src_table_name: srcTableName,
        src_column_name: srcColumnName,
        src_datatype: srcDatatype,
        src_nullable: srcNullable,
        src_comments: srcComments,
        num_vector_results: numVectorResults,
        num_ai_results: numAiResults,
        user_feedback: userFeedback
      })
    })
  }
}

export default {
  checkHealth,
  getData,
  postData,
}

